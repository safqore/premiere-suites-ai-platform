name: Deploy N8N Backend via Render CLI

on:
  workflow_dispatch:
    inputs:
      workflow_n8n_path:
        description: 'N8N workflow to deploy'
        required: false
        default: 'docs/workflows/premiere-suites-demo-workflow.json'

concurrency:
  group: render-deploy-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      RENDER_SERVICE_ID: ${{ vars.RENDER_SERVICE_ID }}
      RENDER_CLI_VERSION: 2.1.5
      DOCKERFILE_PATH: deploy/n8n/Dockerfile
      DOCKER_BUILD_CONTEXT: .
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Preflight (secrets, path)
        id: preflight
        shell: bash
        run: |
          set -euo pipefail
          : "${RENDER_API_KEY:?Missing RENDER_API_KEY secret}"
          : "${RENDER_SERVICE_ID:?Missing RENDER_SERVICE_ID variable}"

          WORKFLOW_PATH="${{ github.event.inputs.workflow_n8n_path || 'docs/workflows/premiere-suites-demo-workflow.json' }}"
          WORKFLOW_PATH="${WORKFLOW_PATH%/}"

          if [[ ! -f "$WORKFLOW_PATH" ]]; then
            echo "❌ Workflow file does not exist: $WORKFLOW_PATH" >&2
            exit 1
          fi

          echo "WORKFLOW_PATH=$WORKFLOW_PATH" >> "$GITHUB_ENV"
          echo "workflow_path=$WORKFLOW_PATH" >> "$GITHUB_OUTPUT"
          echo "✅ Preflight complete: workflow_path=$WORKFLOW_PATH"

      - name: Local Docker build validation (Preflight)
        run: |
          set -euo pipefail
          echo "Validating Docker build using $DOCKERFILE_PATH (context: $DOCKER_BUILD_CONTEXT) ..."
          if [[ ! -f "$DOCKERFILE_PATH" ]]; then
            echo "❌ Dockerfile not found at $DOCKERFILE_PATH" >&2
            exit 1
          fi
          docker build --pull -f "$DOCKERFILE_PATH" -t n8n-workflow-test:validation "$DOCKER_BUILD_CONTEXT"
          echo "✅ Local Docker build succeeded."

      - name: Install Render CLI (pinned)
        run: |
          set -euo pipefail
          echo "Downloading Render CLI v${RENDER_CLI_VERSION}"
          curl -L "https://github.com/render-oss/cli/releases/download/v${RENDER_CLI_VERSION}/cli_${RENDER_CLI_VERSION}_linux_amd64.zip" -o render.zip
          unzip -o -q render.zip
          chmod +x "cli_v${RENDER_CLI_VERSION}"
          sudo mv "cli_v${RENDER_CLI_VERSION}" /usr/local/bin/render
          render --version

      - name: Render login (non-interactive)
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          CI: 'true'
        run: render login --confirm -o json

      - name: Set Render workspace
        env:
          RENDER_WORKSPACE_ID: ${{ vars.RENDER_WORKSPACE_ID }}
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          CI: 'true'
        run: |
          set -euo pipefail
          if [[ -z "${RENDER_WORKSPACE_ID:-}" ]]; then
            echo "❌ RENDER_WORKSPACE_ID not set (add as a repo variable or secret)" >&2
            exit 1
          fi
          echo "Setting Render workspace to $RENDER_WORKSPACE_ID"
          render workspace set "$RENDER_WORKSPACE_ID" --confirm -o json

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      # Render CLI does not allow setting up service (RENDER_SERVICE_ID) via CLI. 
      # Set this up via web front end first in order to use here
      - name: Trigger redeploy
        run: |
          set -euo pipefail
          echo "Triggering Render deploy for $RENDER_SERVICE_ID ..."

          DEPLOY_JSON=$(render services deploy "$RENDER_SERVICE_ID" --confirm -o json 2>/dev/null || true)

          if echo "$DEPLOY_JSON" | jq -e 'type=="array" and (.[0]|has("service"))' >/dev/null 2>&1; then
            echo "Got services list instead of deploy object. Falling back to 'render deploys create'."
            DEPLOY_JSON=$(render deploys create "$RENDER_SERVICE_ID" --confirm -o json)
          elif [[ -z "${DEPLOY_JSON:-}" ]]; then
            echo "Primary deploy command produced no JSON, trying 'render deploys create'."
            DEPLOY_JSON=$(render deploys create "$RENDER_SERVICE_ID" --confirm -o json)
          fi

          echo "Raw deploy response:"
          echo "$DEPLOY_JSON" | jq . || echo "$DEPLOY_JSON"

          DEPLOY_ID=$(echo "$DEPLOY_JSON" | jq -r '
            if type=="array" then
              (.[0].deploy.id? // .[0].deployId? // .[0].id?)
            else
              (.deploy.id? // .deployId? // .id?)
            end
          ')

          if [[ -z "${DEPLOY_ID:-}" || "$DEPLOY_ID" == "null" ]]; then
            echo "Deploy ID not found in response; listing latest deploys for service..."
            LAST_DEPLOY_LIST=$(run_list_json "${LIST_CMD_SINGLE[@]}")
             echo "$LAST_DEPLOY_LIST" | jq . || echo "$LAST_DEPLOY_LIST"
             FALLBACK_ID=$(echo "$LAST_DEPLOY_LIST" | jq -r '.[0].id // empty')
            if [[ -n "${FALLBACK_ID:-}" ]]; then
              DEPLOY_ID="$FALLBACK_ID"
              echo "Using fallback deploy id: $DEPLOY_ID"
            fi
          fi

          if [[ -z "${DEPLOY_ID:-}" || "$DEPLOY_ID" == "null" ]]; then
            echo "❌ Could not obtain deploy id."
            exit 1
          fi

          echo "Deploy ID: $DEPLOY_ID"
          echo "Polling deploy status..."

          # Determine list command syntax compatibility (old vs new CLI)
          if render deploys list --help 2>&1 | grep -q -- '--service'; then
            echo "Detected new deploys list syntax (supports --service / --limit)."
            LIST_CMD_BASE=(render deploys list --service "$RENDER_SERVICE_ID")
            LIST_CMD_SINGLE=(render deploys list --service "$RENDER_SERVICE_ID" --limit 1)
            LIST_CMD_POLL=(render deploys list --service "$RENDER_SERVICE_ID" --limit 50)
          else
            echo "Detected legacy deploys list syntax (positional serviceID, no --limit)."
            LIST_CMD_BASE=(render deploys list "$RENDER_SERVICE_ID")
            LIST_CMD_SINGLE=(render deploys list "$RENDER_SERVICE_ID")
            LIST_CMD_POLL=(render deploys list "$RENDER_SERVICE_ID")
          fi

          # Helper to run list command with JSON output
          run_list_json () {
            "${@}" -o json 2>&1 || true
          }

          : "${RENDER_POLL_MAX_ATTEMPTS:=180}"
          : "${RENDER_POLL_INTERVAL_SECONDS:=5}"

          # Detect if 'render deploys get' subcommand exists in this CLI version.
          echo "Probing 'render deploys get' support..."
          PROBE_OUTPUT=$(render deploys get "$DEPLOY_ID" --confirm -o json 2>&1 || true)
          if echo "$PROBE_OUTPUT" | jq -e . >/dev/null 2>&1; then
            USE_GET=1
            echo "'render deploys get' supported."
          elif grep -q 'Manage service deploys' <<<"$PROBE_OUTPUT"; then
            USE_GET=0
            echo "'render deploys get' not available; will fallback to 'deploys list' polling."
          else
            # Unknown probe result, fallback to list.
            USE_GET=0
            echo "Unrecognized probe output; falling back to list polling."
          fi

          consecutive_non_json=0
          for i in $(seq 1 "$RENDER_POLL_MAX_ATTEMPTS"); do
            if [[ "$USE_GET" -eq 1 ]]; then
              RAW_OUTPUT=$(render deploys get "$DEPLOY_ID" --confirm -o json 2>&1 || true)
            else
              RAW_OUTPUT=$(run_list_json "${LIST_CMD_POLL[@]}")
            fi

            # Validate JSON
            if ! echo "$RAW_OUTPUT" | jq -e . >/dev/null 2>&1; then
              ((consecutive_non_json+=1))
              echo "Non-JSON response (attempt $i, consecutive_non_json=$consecutive_non_json)"
              echo "----- BEGIN RAW -----"
              echo "$RAW_OUTPUT"
              echo "-----  END RAW  -----"

              # If we were using get and it's actually a help screen, switch strategy.
              if [[ "$USE_GET" -eq 1 ]] && grep -q 'Manage service deploys' <<< "$RAW_OUTPUT"; then
                echo "Switching to list-based polling (get unsupported)."
                USE_GET=0
                consecutive_non_json=0
                sleep 1
                continue
              fi

              if grep -qiE 'timeout|temporar|rate|limit|429|5[0-9]{2}|unavailable|network' <<< "$RAW_OUTPUT"; then
                sleep $(( RENDER_POLL_INTERVAL_SECONDS + (consecutive_non_json>5 ? 5 : consecutive_non_json) ))
                continue
              fi

              if (( consecutive_non_json >= 5 )); then
                echo "❌ Aborting: repeated non-JSON responses."
                exit 1
              fi
              sleep "$RENDER_POLL_INTERVAL_SECONDS"
              continue
            fi

            consecutive_non_json=0

            if [[ "$USE_GET" -eq 1 ]]; then
              DEPLOY_OBJ="$RAW_OUTPUT"
            else
              # Select the deploy object with our ID
              DEPLOY_OBJ=$(echo "$RAW_OUTPUT" | jq --arg id "$DEPLOY_ID" -c 'map(select(.id==$id))[0]')
              if [[ -z "$DEPLOY_OBJ" || "$DEPLOY_OBJ" == "null" ]]; then
                echo "Deploy not yet visible in list (attempt $i)."
                sleep "$RENDER_POLL_INTERVAL_SECONDS"
                continue
              fi
            fi

            STATUS=$(echo "$DEPLOY_OBJ" | jq -r '.deploy.status? // .status? // empty')
            PHASE=$(echo "$DEPLOY_OBJ" | jq -r '.deploy.phase? // .phase? // empty')

            printf '[%s] status=%s phase=%s (attempt %s/%s)\n' "$(date -u +%H:%M:%S)" "${STATUS:-unknown}" "${PHASE:-unknown}" "$i" "$RENDER_POLL_MAX_ATTEMPTS"

            case "$STATUS" in
              live)
                echo "✅ Deploy succeeded."
                break
                ;;
              failed|canceled)
                echo "❌ Deploy failed."
                echo "$DEPLOY_OBJ" | jq . || echo "$DEPLOY_OBJ"
                exit 1
                ;;
            esac

            if [[ $i -eq "$RENDER_POLL_MAX_ATTEMPTS" ]]; then
              echo "❌ Timeout waiting for deploy to finish."
              if [[ "$USE_GET" -eq 1 ]]; then
                echo "$RAW_OUTPUT" | jq . || echo "$RAW_OUTPUT"
              else
                echo "$DEPLOY_OBJ" | jq . || echo "$DEPLOY_OBJ"
              fi
              exit 1
            fi
            sleep "$RENDER_POLL_INTERVAL_SECONDS"
          done
